[[{"l":"AppMotor"},{"l":"Packages","p":["Package","Version","Description","AppMotor.Core","NuGet","Core APIs","AppMotor.CliApp","APIs for command line applications; see README.md for details","AppMotor.HttpServer","APIs for running an HTTP(S) server; see README.md for details"]}],[{"l":"APIs for Command Line Apps","p":["This library contains various building blocks for command line applications:","TermText: a string that supports colors and some formatting (like: underline).","Terminal: An alternative to System.Console that only supports cross-platform APIs (and thus make writing Console/Terminal code less error-prone). It also provides direct support for TermText(or any \"raw\" string ANSI escape sequences) by making sure they automatically work on Windows.","CLI Application Framework: Types to make hosting/running CLI applications easier, including proper exception handling, command line parsing and Generic Host support."]},{"l":"Code Documentation","p":["This library has full code documentation. You can find more details about each type there."]}],[{"l":"Command Line Parsing","p":["The base classes CliCommand and CliApplicationWithParams give you access to typed and named command line parameters. You no longer get access to string[] args in your main method - instead you create instances CliParamT(and, optionally CliVerb) to define your command line interface. This also allows for automatic help page generation.","A command line interface definition consists of parameters and verbs (which are either named command or groups of verbs).","Side note: For additional details, see DESIGN-NOTES.md."]},{"l":"Quick Start","p":["In its simplest form, an application can look like this:","This program takes a required server name parameter and an optional parameter --server-cert.","If you need commands/verbs (like the git command), an application can look like this:","or:","The AddCommand can look like this:"]},{"l":"Parameters","p":["anything that has a constructor that takes a single string argument","bool","Named parameters are something like --no-verify or -m in git commit. Named parameters can either have a value (like with -m) or be standalone flags (like --no-verify).","Note that the name from is just used for generating the help page for this parameter - it's not specified on the command line by the end user.","Note that the value is only available from within an \"executor\" method (see below).","number types ( int, double, ...)","Parameters are represented by the CliParamT class. The following C# types are supported:","Parameters come in two variants: named and positional.","Parameters must be defined in a \"container\" - either within a CliCommand or CliApplicationWithParams. Parameters are (usually) defined as instance (i.e. non- static) property or field. These properties or fields can have any visibility (including private).","Positional parameters are defined by the order in which they are specified on the command line. For example, in git mv the first parameter is always the source and the second is always the destination; both are positional parameters.","string","This creates a named parameter with the name --value that takes an int as value.","To access the value of a parameter, simply use the Value property:","To create a positional parameter, define it like this:","You can also define alias names for named parameters, default values (which makes the parameter optional) and help texts:","You can define a named parameter like this:"]},{"l":"Optional Parameters","p":["By default, parameters are considered \"required\". Parameters become \"optional\" if the DefaultValue property is set.","For example, this parameter is required:","While this parameter is optional:","To make a reference type parameter optional, set its default value to null:","Note that the type of the parameter needs to be nullable (e.g. FileInfo?- not FileInfo) for this to work.","There are a few parameter types that are optional by default:","Named parameters of type CliParambool: the default value is set to false; these parameters usually represent \"flags\" (e.g. --verbose)","Parameters with a nullable value type (e.g. CliParamint?): the default value is set to null"]},{"l":"Verbs and Commands","p":["Verbs let you have multiple functions within your application. For example, in git add myfile.cs the word add is such a verb.","Verbs - represented by the CliVerb class - always have a name and usually a command:","Commands are implemented as classes that inherit from CliCommand. Commands have an executor (think: main method) and usually parameters:","The user would execute this command via something like this:","Verbs can also have alias names (like named parameters), a help text, and sub/child verbs."]},{"l":"Verb Groups (Verbs without Command)","p":["Verb groups are simply verbs that just group other verbs under a name.","For example, if you have a CLI api like this:","... then keys would be a verb group (i.e. it doesn't do anything on its own)","Verb groups are simply verbs without a command:"]},{"l":"Putting Everything Together","p":["To make your commands, verbs, and parameters accessible to the end user, you must create an instance of one of the following classes:","An application with multiple functions:","CliApplicationWithVerbs","An application with a single function:","CliApplicationWithParams","CliApplicationWithCommand"]},{"l":"Application with Multiple Functions","p":["As the name suggests, CliApplicationWithVerbs provides access to verbs. It provides multiple functions under one application. It cannot have parameters on its own. Examples for this application type are git or dotnet."]},{"l":"Application with a Single Function","p":["CliApplicationWithParams on the other hand cannot have verbs but only parameters. These applications only provide one function. Examples for this application type are cd, rm, or dir/ ls`. As such, they require an \"executor\" method and usually have parameters (you can think of them as single-command applications).","The same application can be written as an application with a command (with CliApplicationWithCommand):","This form has the advantage that the same MoveCommand can be used with both CliApplicationWithCommand(single function) and CliApplicationWithVerbs(multiple functions)."]},{"l":"Running the Application","p":["To run either application type, simply invoke Run() or RunAsync():","Or:","Or use one of the static Run()/ RunAsync() convenience methods:"]}],[{"l":"Design Notes on the Command Line API","p":["This document contains notes and backgrounds on the design of the Command Line API."]},{"l":"Why another Command Line Parser?","p":["This library actually doesn't implement its own command line parser. Instead it relies on the System.CommandLine NuGet package for parsing (and for help text generation as well).","As a nice side effect, applications using AppMotor.CliApp will automatically get command line auto completion.","The command line API of AppMotor.CliApp just provides the \"opinionated\" frontend for the command line parser."]},{"l":"Why Another Frontend, Then?","p":["At time of writing there were two major command line parsing frontends for C#: System.CommandLine and CommandLineParser.","Each has its own approach on how to give you access to the parameters the end user entered; but both also had things I did not like.","Note: Some of the following is highly opinionated - but these opinions were still the basis on why I wrote this library (instead of using an existing one)."]},{"l":"System.CommandLine","p":["You explicitly define each parameter upfront and then provide a method whose parameter names that must match the parameter definitions you provided earlier. It's big \"magic\".","What I don't like about this approach is that the names of the parameters of your \"main method\" are disconnected from the parameter definition. Rename a parameter (of a private method) and suddenly you command line parsing doesn't work anymore. It's a little bit too fragile for my taste.","Also, at the time of writing, there was almost no source code documentation - making it hard to understand what all the types and methods mean. To be fair, the library was still in beta at this time, but I needed something at that time (and not a couple of months later)."]},{"l":"CommandLineParser","p":["With the CommandLineParser library, you define your commands (or \"verbs\" as they call them) as classes with parameters being properties or fields. To mark fields as cli parameters, you add attributes to them.","I personally like this approach very much (as - from a design standpoint - it doesn't get much cleaner than this). Unfortunately, it has the downside that values for attributes can only be constants. If you need a dynamic default value based, for example, on the operating system, then you can't do this with attributes. You can also not use .NET's resources mechanism to provide translated help texts (e.g. LocalizableResources.HelpText) because the texts are not constants (in the .NET sense).","Sure, the CommandLineParser library gives you ways to do this by some convention - but conventions are not easily discoverable (and you now need to mix clean attributed classes with other mechanisms).","I also found that way the whole thing is plugged together rather unintuitively (although this was not that important).","Aside from all of this there was also the fact that Microsoft now had its own command line parser (System.CommandLine above). I felt more comfortable betting on Microsoft's implementation (might be totally unjustified but no one can predict the future)."]},{"l":"Mixing of Parameter Definition and Value","p":["The design of the CliParamT class mixes the definition of the parameter (e.g. its name) with the value of the parameter (via the Value property).","From a design standpoint, this is a bad design. I'd personally rather have something like attributes on fields/properties. But, as stated above, this approach also has some severe limitations.","In the end, I decided that the ease of use of this design outweighs its not-so-clean design."]},{"l":"I can't do X with this library","p":["As state above, this library is \"opinionated\". There are probably lots of CLIs that can't be expressed with this library. But that's okay. This library wants to be \"easy to use\" rather than \"I can do everything\". It's a 90% solution. When using this library, you're required to adopt your CLI to the possibilities/structure of this library."]},{"l":"Why no Argument Validation?","p":["This library does not contain any argument validation (other than making sure that the text the end user entered can be converted to the desired .NET type). This was done on purpose.","The problem with a built-in argument validation is that you need to provide a proper error text to the end user in case the validation failed. This text can be/is highly situational. We could provide a generic text and allow the developer to customize it somehow - but then the developer could just as easily validate arguments in their executor method and return a non-zero exit code in case of any error.","And so this is the way this library works. It just provides the application with the values that end user entered - everything beyond that is up to the application itself."]}],[{"l":"Generic Host Integration","p":["All CliCommand s provide integration with .NET's Generic Host functionality. Through this integration you get:","A dependency injection (DI) framework","A logging framework(via DI and ILoggerT)","A configuration system","A lifetime of \"hosted services\" - that automatically starts and stops all registered server classes.","Side note: To better understand how IHostBuilder work, see Generic Host - demystified."]},{"l":"How to use the Generic Host","p":["To interact with the Generic Host (via its IHostBuilder interface), you need to override one or both of the following methods in your CliCommand sub class:","ConfigureServices","ConfigureApplication","Like so:","While the command is running, you get access to the DI system via the CliCommand.Services property.","Note: CliCommand.CreateHostBuilder() creates a host builder through the DefaultHostBuilderFactory class. This class creates a host builder with a reduced set of services (compared to Host.CreateDefaultBuilder())."]},{"l":"Running a Server","p":["There's a CliCommand sub class called ServiceHostCliCommand: It's main purpose is to just run one or more servers (HTTP server, file server, ...).","This command runs indefinitely - until explicitly stopped (see below). It's (more or less) the equivalent of .NET's Generic Host wrapped in a CliCommand.","Each server must implemented IHostedService and then be registered via AddHostedService():","Note: If you want to host an HTTP(S) server, it's recommended to use the AppMotor.HttpServer package. See its README for more details."]},{"l":"How to stop a ServiceHostCliCommand","p":["If you're running a ServiceHostCliCommand, you need to stop the command explicitly - or it will run forever.","There are various ways to stop a ServiceHostCliCommand. All of them will shutdown the application gracefully, i.e. by executing any existing shutdown code before terminating:","You hit Ctrl+C.","You can call ServiceHostCliCommand.Stop().","You can obtain (via DI) the IHostApplicationLifetime instance and call StopApplication().","You can pass a CancellationToken to the application's Run() method and then cancel it."]},{"l":"Lifetime events","p":["This ServiceHostCliCommand provides access to various events regarding the lifetime of the command via the IServiceHostLifetimeEvents interface.","You get the instance of IServiceHostLifetimeEvents either via the ServiceHostCliCommand.LifetimeEvents property or via dependency injection."]}],[{"l":"TermText","p":["The TermText API provides an easy way of creating colored console output."]},{"l":"Examples","p":["For a more complete example, see the AppMotor.CliApp.TerminalColorsSample in this repository."]},{"l":"Under the Hood","p":["Under the hood, TermText uses ANSI Escape Sequences for encode colors and styles. These escape sequences are supported out-of-the-box on Linux/Unix and macOS. On Windows, they're supported with Windows 10 or higher and Windows Server 2016 or higher.","If you want to use TermText on Windows without Terminal, you must call AnsiSupportOnWindows.Enable() before the first use."]},{"l":"Credits","p":["TermText's API design was mainly influence by Crayon and Chalk."]}],[{"l":"CLI Application Framework","p":["The AppMotor CLI Application Framework provides you with:","Exception Handling","Command Line Parameter Parsing including an automatically generated help page (optional)","Generic Host (IHostBuilder) Integration(optional)"]},{"l":"Application Classes","p":["All these class inherit from CliApplication and thus inherit all its features.","Class","CLI Parameter Parsing","CLI Parameter Parsing means that you use properties (like string TargetDir { get; set; }) to get the parameters passed by the user on the command line - instead of simply string[] args.","CliApplication","CliApplicationWithCommand","CliApplicationWithParams","CliApplicationWithVerbs","Exception Handling","Generic Host Integration","Generic Host Integration means that you get access to all the features that IHostBuilder/ IHost provide; e.g. dependency injection, configuration, logging.","Multi Command Support","Multi Command Support means that your application can support multiple commands where each command has its own CLI parameters. For example, the git command is a multi command application (with commands being checkout, commit, push, ...) whereas mv/ move are single command applications (and thus would be modeled with CliApplicationWithParams).","no","The class CliApplicationWithCommand is basically the same as CliApplicationWithParams but you specify the parameters and main method on a command instead of the application itself. This class is useful, if you want to use GenericHostCliCommand( details).","The following application classes are available:","yes"]},{"l":"Commands","p":["The following command types are available:","Type","Description","Has Main() Method","CliCommand","Base class for any command","yes","CliVerb","A named CliCommand or command group; required for multi command support","-","GenericHostCliCommand","Command for hosting a service","no","All commands have support for named command line parameters (i.e. Command Line Parameter Parsing).","Commands with a Main() only execute for as long as the main method runs. Commands without a Main() method run indefinitely until stop through some API ( CancellationToken, GenericHostCliCommand.Stop())."]},{"l":"Examples","p":["The simplest form of using CliApplication is like this (in your Program.cs):","There's also an async version:","Alternatively, you can also inherit from CliApplication like so:","The signature of the Execute method is \"dynamic\". It can take string[] args and/or CancellationToken cancellationToken as parameter, be synchronous or async, and return void, int, or bool. For all possible combinations, see the available constructors in CliApplicationExecutor.","If you already have a command (i.e. an instance of CliCommand), you can run an application like so (in your Program.cs):","If you already have a set of CliVerb s (i.e. named CliCommand s), you can run an application like so:","To set the description of you application (for the automatically generated help page), create the appropriate application instance and set the AppDescription property:","For more details and examples on Command Line Parameter Parsing, see here.","For more details and examples on the Generic Host (IHostBuilder) Integration, see here."]},{"l":"Executors","p":["Executors exist to give you the freedom to implement your command's or application's main method however you like: synchronous or async, with or without return value.","To create an instance of an executor, you simply pass a fitting delegate to one of its constructors.","There are two types of executors: CliApplicationExecutor and CliCommandExecutor","Both support (parameter-less) methods/delegates with the following return types: void, Task, bool, Taskbool, int, Taskint","The CliApplicationExecutor also supports methods/delegates that take a single string[] parameter (the command line args).","The class CliCommandExecutor is used by CliCommand and CliApplicationWithParams. This is the only executor you need if you want to work with the command line parsing functionality of this library.","The class CliApplicationExecutor is used by CliApplication(which is an application base class that does not do any command line argument parsing)."]}],[{"l":"Secrets API","p":["Note: The secrets API was partially developed but ultimately discarded because it got too complicated to use (and it took way too long to develop it). This document exists to explain the idea behind the secrets API and to explain why it was discarded."]},{"l":"The problem","p":["Most applications need to work with secrets - passwords, TLS certificates, ...","Usually, one would use either byte[] or string to store these secrets. However, the disadvantage of using these types is that they can live in memory for a long time - even after they have been used for the last time. Instances of these types will only be deleted when the Garbage Collector decides to delete them - and this may only happen if memory runs out, which may not happen for a long time.","This becomes a problem when a developer creates a memory dump of such a process - thereby accidentally leaking secrets, even if they haven't been in use for some time.","Also, one would consider it to be good \"security hygiene\" to keep secrets in memory only as longer as necessary."]},{"l":"The basic idea","p":["The basic idea behind the secrets API was to limit the lifetime of secrets. To do this, there would be dedicated types for storing secrets (namely SecretBytes and SecretString). These types would implement IDisposable and when disposing them, the secrets would be removed from memory:","Internally, on dispose, the memory would simply be cleared. (The secrets would also be pinned to prevent the Garbage Collector from moving them around in memory thereby accidentally creating copies of the secrets.)","If this all sounds familiar, it's basically the same implementation as .NET's own SecureString- only also extended to bytes."]},{"l":"Why was this API discarded?","p":["While all of this moght sound like a good idea, the API was ultimately discard. The primary reason: it was too complex to use.","In the experiment we did (which took multiple weeks), simple APIs would get very complicated/complex to use when the secrets API was used. On the other hand, the benefit of using the secrets API was just too small to justify a more complex API. (Also, the implementation toke too long without seeing an actual benefit.)","It seems that even Microsoft found that this way is too complicated. The documentation of SecureString contains this note:","We don't recommend that you use the SecureString class for new development. For more information, see SecureString shouldn't be used on GitHub.","With the conclusion:","The general approach of dealing with credentials is to avoid them and instead rely on other means to authenticate, such as certificates or Windows authentication.","The following sections will explain some of the problems we encountered while developing the secrets API."]},{"l":"No support from .NET","p":["At the time of writing (.NET 5), there was no support for (the concept of) such a secrets API in .NET itself. This becomes a problem at the \"boundaries\" - i.e. the various ways of how the secrets would enter or leave the process.","All of .NET's I/O classes (e.g. File, Stream, HttpClient) use various methods of buffering or even string building when used. All of these may leak (parts of) the secrets they read or write - especially if there is an exception (since none of the implementations clears their buffers when exceptions occur).","For most of these problems, we found ways to reduce the chance of leaking. But all of these ways relied on knowing exactly how the various methods are implemented. And relying on implementation details for security is very bad - especially since most of these implementation details could not be validated via automatic tests.","Also, this whole problem would get even more trickier when RPC/REST frameworks like ASP.NET Core or gRPC."]},{"l":"Ownership and lifetime problems","p":["While the ownership and lifetime of a single secret may be clear, things get complicated if the secrets needs to be transformed within the API that uses it.","The primary example in our experiment was conversion between SecretBytes and SecretString. Consider the following example (constructor of the class PemCertificateSource):","In the first constructor, the newly created instance owns _pemEncodedCertificate but not _separatePemEncodedPrivateKey. In the second constructor, it's the other way around.","One idea to solve this problem was to always create copies of secrets. While this would solve this problem (and other problems like it), it's very easy to forget creating copies when implementing your own API (an example of why using the secrets API is complicated).","Also, either way, the class PemCertificateSource would need to implement IDisposable- which makes using it more complicated (think of the \"ripple effect\" of introducing IDisposable).","Another idea of how to solve this problem was to introduce a SecretsScope but this also did not pan out; see below for more details."]},{"l":"SecretsScope","p":["To solve the problems with the complex ownerships of secrets, one idea was to always store them encrypted in memory - with an overall scope limiting the lifetime of all secrets created with it:","The idea behind this was to encrypt all secrets with a key stored in the SecretsScope and when the SecretsScope was disposed, the key would simply be \"thrown away\" (thus secrets could not be decrypted anymore even if they still existed in memory).","The biggest problem with this approach is: The user of the APIs that use the secret APIs needs to know how long to keep the scope open.","This would either require experimentation (i.e. you only know at runtime if you closed the scope too early) or complicated re-encryption of secrets with owners of different lifetimes.","In the end, this approach was also deemed too complicated (for the little benefit it would bring)."]},{"l":"Conclusion","p":["The effort of implementing and (safely) using the secrets API was too big for the little benefit it brought.","In future, we may revive this API if we find a simpler way to use and to implement it."]}],[{"l":"Certificates API","p":["The certificates API exists to make it easier to use/manage TLS certificates. It's a thin wrapper around .NET's own X509Certificate2 API."]},{"l":"Certificates Mini Primer","p":["Certificates are a complicated topic but the day-to-day use is not that complicated. This section give a quick introduction into (TLS) certificates.","First off, TLS certificates provide the following functions:","Confidentiality: the transmitted data is encrypted and can't be read by man-in-the-middle attackers","Integrity: the transmitted data can't be tampered with by man-in-the-middle attackers","Authentication: the sender can be sure to talk to the correct receiver","Functions 1 and 2 are provided by certificates themselves.","Function 3 is a little bit more complicated. The most common way is for a CA (certificate authority) to \"sign\" the certificate. This signature can be validate. Each operating system has a list of CAs that are trusted.","Certificates consist of a public key and a private key. The public key is known to everyone, the private key is only known to the server itself. A sender can encrypt data with a public key and only the owner of the private key can then decrypt the data.","Public keys (and thereby also the private keys) are created using a key algorithm. The most commonly used is RSA, but ECDSA is also gaining support. For compatibility reason, it's still recommended to create RSA keys.","For storing certificates on disk, there are basically three formats: pfx, pem, and der. Files in pfx format usually store public and private key in a single (password encrypted) file while files in pem format store those keys in separate files. Files in der format seem to be very uncommon."]},{"l":"Loading a certificate","p":["To load a certificate with this API, first create an instance of TlsCertificateSource. For example, if the certificate is on disk, simply use:","The certificate may or may not contain a private key. The certificates API does not care.","Next, to create an actual certificate from this source, simply pass it to one of the constructors of TlsCertificate:","If the certificate is password protected, also pass the password:","To use this certificate, pass it to any API that takes a X509Certificate2 parameter."]},{"l":"Creating a self-signed certificate","p":["To create a self-signed certificate for example.com that's valid for 20 days, use:","Or:"]},{"l":"Exporting a certificate","p":["To export a certificate, you need to decide whether to:","export public key and private key - or just the public key","export as pfx or pem","For example, to export the public key as pem into a byte array, use:","To export the public and the private key as pfx into a file, use:","Note: The private key must be exportable for this to work. This flag is set during the creation of the TlsCertificate instance."]}],[{"l":"APIs for running a HTTP(S) Server","p":["This package provides APIs to host an HTTP(S) (ASP.NET Core) server (in a console application)."]},{"l":"How to use","p":["First, you need to have an ASP.NET Core project.","The simplest form to use this package is to create a Program.cs with the following content:","This will enable ASP.NET Core controllers and Razor views via HTTP on port 1234 on localhost.","To make the server reachable from another machine, change the code to this:","You can also pass a CancellationToken to be able to stop the server at any given time (by default it's stopped by pressing Ctrl+C):","To enable HTTPS, you need to obtain a certificate and then use some code like this:","Note: You can extend MyServerCommand with CliParam s. See the CommandLine parsing documentation.","This will use the class AppMotor.HttpServer.MvcStartup as ASP.NET Startup class. If you want to use your own Startup class, simply override CreateStartupClass:"]}],[{"l":"AppMotor .NET Standard 2.0 Compatibility Library","p":["This library adds various helpers and attributes required to use modern C# features with .NET Standard 2.0 (or compatible) code."]}]]